/*
    Copyright (C) 2008-2009 RÃ´mulo Fernandes Machado <romulo@castorgroup.net>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef _GUI_MANAGER_H
#define _GUI_MANAGER_H

#include "prerequisites.h"
#include "fileParser.h"
#include "singleton.h"
#include "sticker.h"

namespace k
{
	/**
	 * \brief Signals type.
	 */
	typedef enum
	{
		SIGNAL_CLICK,
		SIGNAL_CHANGED,
		SIGNAL_KEYPRESS 
	} signalType_t;

	/**
	 * \brief Mouse/Pointer event params for gui signals.
	 */
	typedef enum
	{
		BUTTON_LEFT,
		BUTTON_RIGHT,
		BUTTON_WHEEL_UP,
		BUTTON_WHEEL_DOWN
	} mouseParams_t;

	/**
	 * \brief Mouse structure for mouse/pointer signals.
	 */
	typedef struct
	{
		mouseParams_t mParam;
		vector2 mPosition;
	} mouseState_t;

	/**
	 * \brief Signal information.
	 */
	typedef struct
	{
		signalType_t type;
		mouseState_t mouseState;
		unsigned int key;
	} signalInfo_t;

	/**
	 * \brief A base class to make gui signal handlers
	 * This class describe a base class where you can derive
	 * your classes that will handle gui signal events.
	 */
	class DLL_EXPORT signalHandler {};

	/**
	 * \brief Signal Handle Information.
	 */
	typedef struct
	{
		signalHandler* handler;
		void(signalHandler::*function)(signalInfo_t, void*);
		void* userData;
	} signalHandlerInfo_t;

	/**
	 * \brief A base class to store and use signals.
	 */
	class DLL_EXPORT signalKeeper
	{
		protected:
			std::map<std::string, signalHandlerInfo_t*> mSignals;

		public:
			/**
			 * Connect a signal to a handler.
			 * A signal is an event generated by the GUI and the handle is a function specified by the user to 
			 * handle the signal. Each signal can only have one handle and valid signals name are:
			 * "click", "changed" and "keyPressed". User can also specify some data to be passed
			 * to the handle when the signal is called.
			 *
			 * @sname The name of the signal to connect the handle function.
			 * @handle The handle function.
			 * @userData Custom user data, can be NULL.
			 */
			void connect(const std::string& sname, signalHandlerInfo_t* info);

			/**
			 * Disconnect a handle from a signal. The memory used by the handle will be free'd.
			 * @sname The name of the signal.
			 */
			void disconnect(const std::string& sname);

			/**
			 * Call the signal handle by name.
			 */
			void callSignal(const std::string& sname, signalInfo_t info);
	};

	extern const char* DLL_EXPORT panelEdges[];	
	
	typedef enum
	{
		E_TOPLEFT,
		E_TOPMIDDLE,
		E_TOPRIGHT,
		E_LEFT,
		E_MIDDLE,
		E_RIGHT,
		E_BOTTOMLEFT,
		E_BOTTOMMIDDLE,
		E_BOTTOMRIGHT,

		E_MAX_EDGES
	} skinEdges;

	/**
	 * \brief GUI Panel. Hold other widgets.
	 */
	class DLL_EXPORT panel  : public signalKeeper, public drawable2D
	{
		protected:
			std::vector<drawable2D*> mChilds;

			rectangle* mSkin[E_MAX_EDGES];
			material* mSkinMaterial;
			vector2 mSkinDimensions;

			vector3* mVertices;
			vector2* mUvs;

			/**
			 * Set panel skin data.
			 */
			void _setSkinData(const char** skinNamesArray);

		public:
			/**
			 * Create a new panel. Dimensionless.
			 */
			panel();

			/**
			 * Create a new panel.
			 * @pos The panel position.
			 * @dimension The panel dimension.
			 */
			panel(const vector2& pos, const vector2& dimension);

			virtual ~panel();
			void draw();
	};

	/**
	 * \brief Handle basic GUI operations.
	 */
	class DLL_EXPORT guiManager : public singleton<guiManager>
	{
		protected:
			sticker* mCursor;

			/**
			 * Last cursor position.
			 */
			vector2 mCursorLastPos;

			/**
			 * Cursor Delta position.
			 */
			vector2 mCursorDeltaPos;

			/**
			 * GUI elements skin material.
			 */
			material* mGuiSkin;

			/**
			 * GUI material dimensions.
			 */
			vector2 mSkinDimensions;

			/**
			 * Skin definitions for panels
			 */
			std::map<std::string, rectangle*> mSkinDefinitions;

		public:
			/**
			 * Controls the GUI System
			 * Keep in mind that this class is automatically 
			 * instantiated by the root
			 */
			guiManager();

			/**
			 * Destructor
			 */
			~guiManager();

			/**
			 * Get skin definition for a named widget type.
			 * @wname The widget type name.
			 */
			rectangle* getSkinDefinition(const std::string& wname) const;

			/**
			 * Get skin material.
			 */
			material* getSkinMaterial() const
			{
				return mGuiSkin;
			}

			/**
			 * Get skin dimensions.
			 */
			const vector2& getSkinDimensions() const
			{
				return mSkinDimensions;
			}

			/**
			 * Return this guiManager singleton instance.
			 */
			static guiManager& getSingleton();

			/**
			 * Set gui elements skin material and definitions file.
			 * @matName The name of the skin material.
			 * @guiFile The full path to the skin definitions file.
			 */
			void setSkin(const std::string& matName, const std::string& guiFile);

			/**
			 * Set the cursor to show on screen on mouse events
			 * keep in mind that this class needs an renderer
			 * to work automatically. If you dont want to use a renderer
			 * get the cursor sticker and draw it by yourself in your render loop.
			 */
			void setCursor(const std::string& mat, const vector2& scale);

			/**
			 * Returns the cursor position.
			 */
			const vector2 getCursorPosition() const;

			/**
			 * Returns the cursor movement since last frame.
			 */
			const vector2& getCursorDeltaPosition() const;

			/**
			 * Take care of events, handle elements and update cursor position.
			 */
			void update();
	};
}

#endif

