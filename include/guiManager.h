/*
    Copyright (C) 2008-2009 RÃ´mulo Fernandes Machado <romulo@param castorgroup.net>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef _GUI_MANAGER_H
#define _GUI_MANAGER_H

#include "prerequisites.h"
#include "fileParser.h"
#include "singleton.h"
#include "sticker.h"

namespace k
{
	/**
	 * \brief Signals type.
	 */
	typedef enum
	{
		SIGNAL_MOUSEIN,
		SIGNAL_MOUSEOUT,
		SIGNAL_MOUSEMOVE,
		SIGNAL_KEYDOWN,
		SIGNAL_KEYUP
	} signalType_t;

	/**
	 * \brief Mouse/Pointer event params for gui signals.
	 */
	typedef enum
	{
		BUTTON_LEFT = (1 << 0),
		BUTTON_RIGHT = (1 << 1),
		BUTTON_WHEEL_UP = (1 << 2),
		BUTTON_WHEEL_DOWN = (1 << 3)
	} mouseParams_t;

	/**
	 * \brief Mouse structure for mouse/pointer signals.
	 */
	typedef struct
	{
		unsigned int buttons;
		vector2 mPosition;
	} mouseState_t;

	/**
	 * \brief Signal information.
	 */
	typedef struct
	{
		signalType_t type;
		mouseState_t mouseState;
		unsigned int key;
	} signalInfo_t;

	/**
	 * \brief A base class to make gui signal handlers
	 * This class describe a base class where you can derive
	 * your classes that will handle gui signal events.
	 */
	class DLL_EXPORT signalHandler {};

	typedef DLL_EXPORT bool(signalHandler::*signalFunctionPtr)(signalInfo_t, void*);

	/**
	 * \brief Signal Handle Information.
	 */
	typedef struct
	{
		// A pointer to the class instance holding the handle.
		signalHandler* handler;

		// A pointer to the handle itself.
		bool (signalHandler::*function)(signalInfo_t, void*);

		// Any user specified data.
		void* userData;
	} signalHandlerInfo_t;

	/**
	 * \brief A base class to store and use signals.
	 */
	class DLL_EXPORT signalKeeper
	{
		protected:
			std::map<std::string, signalHandlerInfo_t*> mInternalSignals;
			std::map<std::string, signalHandlerInfo_t*> mSignals;

		public:
			/**
			 * Connect a signal to a handler.
			 * A signal is an event generated by the GUI and the handle is a function specified by the user to 
			 * handle the signal. Each signal can only have one handle and valid signals name are:
			 * "keyDown", "keyUp", "mouseIn", "mouseOut", "mouseMove". 
			 *
			 * User can also specify some data to be passed to the handle when the signal is called.
			 *
			 * @param sname The name of the signal to connect the handle function.
			 * @param handle The handle function.
			 * @param userData Custom user data, can be NULL.
			 */
			void connect(const std::string& sname, signalHandlerInfo_t* info);

			/**
			 * Disconnect a handle from a signal. The memory used by the handle will be free'd.
			 * @param sname The name of the signal.
			 */
			void disconnect(const std::string& sname);

			/**
			 * Call the signal handle by name.
			 * Returns true if the called has blocked the signal, that way the signal will stop
			 * its propagation to other widgets/handlers.
			 */
			bool callSignal(const std::string& sname, signalInfo_t info);
	};
	
	/**
	 * \brief Shows the order of skin elements to be loaded
	 * and used on skin names array.
	 */
	typedef enum
	{
		E_TOPLEFT,
		E_TOPMIDDLE,
		E_TOPRIGHT,
		E_LEFT,
		E_MIDDLE,
		E_RIGHT,
		E_BOTTOMLEFT,
		E_BOTTOMMIDDLE,
		E_BOTTOMRIGHT,

		E_MAX_EDGES
	} skinEdges;

	/**
	 * \brief Hold skin information for a widget. 
	 * This class can hold a skinned area for widgets, allowing them
	 * to have multiple skins if desired. Each skin can be drawn by calling
	 * the draw() method. Keep in mind that you need to define the position
	 * and the drawing rectangle for each skin area.
	 */
	class DLL_EXPORT widgetSkin : public drawable2D
	{
		protected:
			rectangle* mSkin[E_MAX_EDGES];
			material* mSkinMaterial;
			vector2 mSkinDimensions;

			vector3* mVertices;
			vector2* mUvs;

		public:
			/**
			 * Create a new widget skin. Should be called
			 * on derivated widgets constructors.
			 */
			widgetSkin()
			{
				mVertices = NULL;
				mUvs = NULL;
			}

			/**
			 * Free widget skin pointers.
			 */
			~widgetSkin()
			{
				if (mVertices)
					free(mVertices);

				if (mUvs)
					free(mUvs);
			}
			
			/**
			 * Set skin data.
			 * @param skinNamesArray An array of C-strings (char*) with each name of
			 * the skin component in the skin xml. Keep in mind that you must use the
			 * right order for the skin component names, you can check the correct order 
			 * in @skinEdges
			 */
			void setSkinData(const char** skinNamesArray);

			/**
			 * Draw this skin.
			 */
			void drawWidgetSkin();

			/**
			 * Tells if the pointer is inside this widget area.
			 */
			bool isPointerInside(const vector2& pos) const;
	};

	/**
	 * \brief Panel skin names array.
	 */
	extern const char* DLL_EXPORT panelEdges[];	

	/**
	 * \brief Just a base class to derive widgets from.
	 * Make sure you are calling widget constructor on your
	 * class constructor.
	 */
	class DLL_EXPORT widget : public widgetSkin, public signalKeeper
	{
		protected:
			/**
			 * Is mouse in this widget?
			 */
			bool mMouseIn;

			/**
			 * All mouse buttons down on this widget.
			 */
			unsigned int mMouseButtons;

		public:
			widget() : widgetSkin()
			{
				mMouseIn = false;
				mMouseButtons = 0;
			}
			
			virtual bool mousemove(signalInfo_t info, void* userData);
	};

	/**
	 * \brief Panel widget, hold other widgets.
	 * The panel is basically a skinned box which hold another
	 * types of widgets within its area. Every widget contained in the
	 * panel will only be drawn if the panel is visible and will be free'd
	 * upon panel's deletion.
	 */
	class DLL_EXPORT panelWidget : public widget, public signalHandler
	{
		protected:
			std::vector<drawable2D*> mChilds;

			void _registerSignals();

		public:
			/**
			 * Create a new panel. Dimensionless.
			 */
			panelWidget();

			/**
			 * Create a new panelWidget.
			 * @param pos The panelWidget position.
			 * @param dimension The panelWidget dimension.
			 */
			panelWidget(const vector2& pos, const vector2& dimension);

			/**
			 * Panel destructor. Keep in mind that destroying
			 * the panelWidget will also destroy every child of it, freeing
			 * their memory pointers.
			 */
			virtual ~panelWidget();

			/**
			 * Draw the panel (called internally by guiManager)
			 */
			void draw();

			// handle mousemove
			bool mousemove(signalInfo_t info, void* userData);
			bool mousein(signalInfo_t info, void* userData);
			bool mouseout(signalInfo_t info, void* userData);
	};

	/**
	 * \brief Handle basic GUI operations.
	 */
	class DLL_EXPORT guiManager : public singleton<guiManager>
	{
		protected:
			sticker* mCursor;

			/**
			 * Last cursor position.
			 */
			vector2 mCursorLastPos;

			/**
			 * Cursor Delta position.
			 */
			vector2 mCursorDeltaPos;

			/**
			 * GUI elements skin material.
			 */
			material* mGuiSkin;

			/**
			 * GUI material dimensions.
			 */
			vector2 mSkinDimensions;

			/**
			 * Skin definitions for panels
			 */
			std::map<std::string, rectangle*> mSkinDefinitions;

			/**
			 * All registered widgets.
			 */
			std::vector<widget*> mWidgets;

		public:
			/**
			 * Controls the GUI System
			 * Keep in mind that this class is automatically 
			 * instantiated by the root
			 */
			guiManager();

			/**
			 * Destructor
			 */
			~guiManager();

			/**
			 * Get skin definition for a named widget type.
			 * @param wname The widget type name.
			 */
			rectangle* getSkinDefinition(const std::string& wname) const;

			/**
			 * Get skin material.
			 */
			material* getSkinMaterial() const
			{
				return mGuiSkin;
			}

			/**
			 * Get skin dimensions.
			 */
			const vector2& getSkinDimensions() const
			{
				return mSkinDimensions;
			}

			/**
			 * Return this guiManager singleton instance.
			 */
			static guiManager& getSingleton();

			/**
			 * Set gui elements skin material and definitions file.
			 * @param matName The name of the skin material.
			 * @param guiFile The full path to the skin definitions file.
			 */
			void setSkin(const std::string& matName, const std::string& guiFile);

			/**
			 * Set the cursor to show on screen on mouse events
			 * keep in mind that this class needs an renderer
			 * to work automatically. If you dont want to use a renderer
			 * get the cursor sticker and draw it by yourself in your render loop.
			 */
			void setCursor(const std::string& mat, const vector2& scale);

			/**
			 * Push a widget into the widgets list of guiManager.
			 */
			void pushWidget(widget* w);

			/**
			 * Returns the cursor position.
			 */
			const vector2 getCursorPosition() const;

			/**
			 * Returns the cursor movement since last frame.
			 */
			const vector2& getCursorDeltaPosition() const;

			/**
			 * Take care of events, handle elements and update cursor position.
			 */
			void update();
	};
}

#endif

